<!DOCTYPE html>
<html>
<head>
    <title>tai chi workout</title>
</head>
<body>
<script>

    var emitEvents = (function (undefined) { 

        var on = function (event, callback, context) {

                var callbacks = getCallbacks(this);
                // fetch the event's store of callbacks or create it if needed
                var store = callbacks[event] || (callbacks[event] = []);

                // store the callback for later use
                store.push({
                    callback: callback,
                    context: context || window || null
                });

                // also on to the context object's destroy event in order to off
                if (context.on !== on) {
                    emitEvents.apply(context);
                }
                context.on('silenceEvents', function () {
                    off.call(this, event, callback, context);
                }, this);
                
            },

            off = function (event, callback, context) {
                var callbacks = getCallbacks(this, true);
                if (!callbacks) {return false;}
                var store = callbacks[event],
                    i;

                if (!store) {return;}

                // fast loop
                for (i = store.length - 1; i>=0; i--) {
                    if (store[i].callback === callback && (!context || !(store[i].context) || store[i].context === context)) {

                        // I might have got the index wrong here - shoudl it be i-1. Obviously I'd check thoroughly in a real app
                        store.splice(i, 1);
                    }
                }
            },

            fire = function (event, result) {
                var callbacks = getCallbacks(this);
                var store = callbacks[event],
                    i = 0,
                    il;
                console.log('Event emitted', '\nemitter: ', this, '\nevent:', event, '\ndata: ', result);
                if (!store) {return;}

                // loop here must be in increasing order
                for (il = store.length; i<il; i++) {
                    store[i].callback.call(store[i].context, this, event, result);
                }
                
            },

            getCallbacks = function (obj, dontSet) {
                for (var i = 0, il = contexts.length; i < il; i++) {
                    if (contexts[i] === obj) {
                        return callbacks[i];
                    }
                }
                if (!dontSet) {
                    contexts.push(obj);
                    callbacks.push([]);
                    return callbacks[callbacks.length - 1];
                } else {
                    return undefined;
                }
            },

            callbacks = [],
            contexts = [];

        return function (config) { 

            this.on = on;
            this.off = off;
            this.fire = fire;

            return this;
        };

    })(undefined);


    function pickRandomProperty (obj) {
        var result;
        var count = 0;
        for (var prop in obj)
            if (Math.random() < 1 / ++count) {
                result = prop;
            }
               
        return result;
    }

    function defineProps (obj) {
        var prop;
        for (var key in obj) {
            prop = obj[key];
            if (prop._propertyDefinition) {
                delete obj[key];
                Object.defineProperty(obj, key, prop);
            }
        }
        return obj;
    }

    function extendObj (base) {
        var extenders = Array.prototype.slice.call(arguments, 1),
            extender;

        if (!extenders.length) {
            return base;
        }

        if (extenders.length > 1) {
            extender = extendObj.apply(this, extenders);
        } else {
            extender = extenders[0];    
        }

        for (var key in extender) {
            base[key] = extender[key];    
        }

        return base;
    }

    var L = 'Left',
        R = 'Right',
        N = 'North',
        S = 'South',
        E = 'East',
        W = 'West',
        compass = [N, E, S, W];

    var Driller = function (conf) {
        var discipline = (conf && conf.discipline) || Driller.defaults.discipline;
        this.conf = extendObj({}, Driller.defaults, Driller.disciplineConfigs[discipline], conf || {});
        this.init();
    };

    Driller.defaults = {
        discipline: 'taiChi',
        minTime: 2,
        maxTime: 4,
        avgTime: 3,
        avgWeight: 1
    };

    Driller.disciplineConfigs ={
        taiChi: {
            steps: {
                step: {
                    frontFoot: 1,
                    move: [1, 0],
                    direction: 0
                },
                back: {
                    frontFoot: 1,
                    move: [-1, 0],
                    direction: 0
                },
                shift: {
                    frontFoot: 1,
                    move: [0, 0],
                    direction: -1 // indicates turning away from front foot
                },
                'switch': {
                    frontFoot: 1,
                    move: [0, 0],
                    direction: 0
                },
                inside: {
                    frontFoot: 0,
                    move: [0, 1],
                    direction: 0
                },
                outside: {
                    frontFoot: 0,
                    move: [0, -1],
                    direction: 0
                },
                onGuard: {
                    _propertyDefinition: true,
                    enumerable: false,
                    value: {
                        frontFoot: L,
                        move: [-0.5, 0.5],
                        direction: 0
                    }
                },
                wuChi: {
                    _propertyDefinition: true,
                    enumerable: false,
                    value: {
                        frontFoot: false,
                        move: [0.5, -0.5],
                        direction: 0                    
                    }
                }
            },
            startSequence: ['wuChi', 'onGuard'],
            endSequence: ['wuChi']
        }
    }

    for (var key in Driller.disciplineConfigs) {
        defineProps(Driller.disciplineConfigs[key].steps);
    }

    Driller.prototype = {
        init: function () {
            this.square = [0,0];
            this.frontFoot = null;
            this.direction = 0;
        },
        start: function (reset) {
            if (reset) {
                this.init();
            }
            this.fire('started');
            this.startSequence = this.conf.startSequence.slice();
            this.announceStep(this.startSequence.shift());
            this.takeStep();
        },
        announceStep: function (step) {
            this.fire('step', {
                direction: compass[this.direction],
                frontFoot: this.frontFoot,
                lastStep: step,
                square: this.square[0] + ':' + this.square[1]
            });
        },
        stop: function () {
            clearTimeout(this.timer);
            this.endSequence = this.conf.endSequence.slice();
            this.takeStep(true);
            this.fire('stopped');
        },
        takeStep: function (closing) {
            var that = this;
            var step = this.getNextStepName(closing);
            if (closing) {
                this.adjustPosition(step);
                if (this.endSequence.length) {
                    that.takeStep(closing);
                }
            } else {
                this.timer = setTimeout(function () {
                    that.adjustPosition(step);
                    that.takeStep();
                    // remember to do this on sound finish (maybe?)
                }, this.getTimeInterval());    
            }
        },
        getNextStepName: function (closing) {
            if (closing) {
                return this.endSequence.shift();
            } else if (this.startSequence.length) {
                return this.startSequence.shift();
            } else {
                return pickRandomProperty(this.conf.steps);
            }
        },
        adjustPosition: function (step) {
            var moveMatrix,
                leftToRight,
                frontToBack;
            this.currentStep = this.conf.steps[step];
            this.direction = (this.direction + ((this.frontFoot === R ? 1 : -1) * this.currentStep.direction) + 4) % 4;
    
            leftToRight = this.currentStep.move[1] * (this.currentStep.frontFoot === L ? -1: 1);
            frontToBack = this.currentStep.move[0];

            if (this.currentStep.frontFoot) {

                this.frontFoot = this.currentStep.frontFoot === L ? L :
                                this.currentStep.frontFoot === R ? R :
                                    this.frontFoot === R ? L : R;
            }
            
            switch (this.direction) {
                case 0:     
                    moveMatrix = [frontToBack, leftToRight];
                    break;
                case 1:     
                    moveMatrix = [-leftToRight, frontToBack];
                    break;
                case 2:     
                    moveMatrix = [-frontToBack, -leftToRight];
                    break;
                case 3:
                    moveMatrix = [leftToRight, -frontToBack];
                    break;

            }

            this.square = [this.square[0] + moveMatrix[0], this.square[1] + moveMatrix[1]];

            this.announceStep(step);
        },

        getTimeInterval: function () {
            var time = ((((this.conf.maxTime - this.conf.minTime) * Math.random())/(this.conf.avgWeight + 1)) + (this.conf.avgTime *(this.conf.avgWeight/(this.conf.avgWeight + 1)))) + this.conf.minTime;
            time = Math.max(Math.min(this.conf.maxTime, time), this.conf.minTime);
            //console.log(time);
            return 1000;
            return time * 1000;
        },
        updateSettings: function (conf) {
            this.conf = extendObj(this.conf, conf);
            this.start();
        },
        defineStep: function (name, conf) {
            this.steps[name] = conf;
        },
        undefineStep: function (name) {
            if (this.steps[name]) {
                delete this.steps[name];
            }
        }
    }

    emitEvents.apply(Driller.prototype);

    // bursts (repeat and random, and inbetween)
    // gradual speed up
    // available room (or infinite)
    // use the accelerometer to measure success
    // use an event aggregator
    // find a way of giving steps weight
    // publish the event emitter
    // easily enable and disable steps (and change frequency)
    var driller = new Driller();

    driller.start();

    setTimeout(function () {
        driller.stop();
        setTimeout(function () {
           // driller.start();
        }, 5000);
    }, 4000);


</script>
</body>
</html>